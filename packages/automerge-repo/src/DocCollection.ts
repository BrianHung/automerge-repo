import EventEmitter from "eventemitter3"
import { DocHandle } from "./DocHandle.js"
import { EncodedDocumentId, type DocumentId, AutomergeUrl } from "./types.js"
import { type SharePolicy } from "./Repo.js"
import {
  decodeDocumentId,
  encodeDocumentId,
  generateAutomergeUrl,
  parseAutomergeUrl,
} from "./DocUrl.js"

/**
 * A DocCollection is a collection of DocHandles. It supports creating new documents and finding
 * documents by ID.
 * */
export class DocCollection extends EventEmitter<DocCollectionEvents> {
  #handleCache: Record<EncodedDocumentId, DocHandle<any>> = {}

  /** By default, we share generously with all peers. */
  sharePolicy: SharePolicy = async () => true

  constructor() {
    super()
  }

  /** Returns an existing handle if we have it; creates one otherwise. */
  #getHandle<T>(
    /** The documentId of the handle to look up or create */
    encodedDocumentId: EncodedDocumentId,

    /** If we know we're creating a new document, specify this so we can have access to it immediately */
    isNew: boolean
  ) {
    // If we have the handle cached, return it
    if (this.#handleCache[encodedDocumentId])
      return this.#handleCache[encodedDocumentId]

    // If not, create a new handle, cache it, and return it
    const documentId = decodeDocumentId(encodedDocumentId)
    if (!documentId) throw new Error(`Invalid documentId ${encodedDocumentId}`)
    const handle = new DocHandle<T>(documentId, { isNew })
    this.#handleCache[encodedDocumentId] = handle
    return handle
  }

  /** Returns all the handles we have cached. */
  get handles() {
    return this.#handleCache
  }

  /**
   * Creates a new document and returns a handle to it. The initial value of the document is
   * an empty object `{}`. Its documentId is generated by the system. we emit a `document` event
   * to advertise interest in the document.
   */
  create<T>(): DocHandle<T> {
    // TODO:
    // either
    // - pass an initial value and do something like this to ensure that you get a valid initial value

    // const myInitialValue = {
    //   tasks: [],
    //   filter: "all",
    //
    // const guaranteeInitialValue = (doc: any) => {
    // if (!doc.tasks) doc.tasks = []
    // if (!doc.filter) doc.filter = "all"

    //   return { ...myInitialValue, ...doc }
    // }

    // or
    // - pass a "reify" function that takes a `<any>` and returns `<T>`

    // Generate a new UUID and store it in the buffer
    const { encodedDocumentId } = parseAutomergeUrl(generateAutomergeUrl())
    const handle = this.#getHandle<T>(encodedDocumentId, true) as DocHandle<T>
    this.emit("document", { handle })
    return handle
  }

  /**
   * Retrieves a document by id. It gets data from the local system, but also emits a `document`
   * event to advertise interest in the document.
   */
  find<T>(
    /** The documentId of the handle to retrieve */
    automergeUrl: AutomergeUrl
  ): DocHandle<T> {
    const { encodedDocumentId } = parseAutomergeUrl(automergeUrl)
    // If we have the handle cached, return it
    if (this.#handleCache[encodedDocumentId])
      return this.#handleCache[encodedDocumentId]

    const handle = this.#getHandle<T>(encodedDocumentId, false) as DocHandle<T>
    this.emit("document", { handle })
    return handle
  }

  delete(
    /** The documentId of the handle to delete */
    encodedDocumentId: EncodedDocumentId
  ) {
    const handle = this.#getHandle(encodedDocumentId, false)
    handle.delete()

    delete this.#handleCache[encodedDocumentId]
    this.emit("delete-document", {
      encodedDocumentId: encodedDocumentId,
    })
  }
}

// events & payloads
interface DocCollectionEvents {
  document: (arg: DocumentPayload) => void
  "delete-document": (arg: DeleteDocumentPayload) => void
}

interface DocumentPayload {
  handle: DocHandle<any>
}

interface DeleteDocumentPayload {
  encodedDocumentId: EncodedDocumentId
}
