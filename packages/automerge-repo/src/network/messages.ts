// utilities
import { DocumentId, PeerId, SessionId } from "../types.js"
export { type SessionId } from "../types.js"

export function isValidMessage(
  message: NetworkAdapterMessage
): message is
  | SyncMessage
  | EphemeralMessage
  | RequestMessage
  | DocumentUnavailableMessage {
  return (
    typeof message === "object" &&
    typeof message.type === "string" &&
    typeof message.senderId === "string" &&
    (isSyncMessage(message) ||
      isEphemeralMessage(message) ||
      isRequestMessage(message) ||
      isDocumentUnavailableMessage(message))
  )
}

export function isDocumentUnavailableMessage(
  message: NetworkAdapterMessage
): message is DocumentUnavailableMessage {
  return message.type === "doc-unavailable"
}

export function isRequestMessage(
  message: NetworkAdapterMessage
): message is RequestMessage {
  return message.type === "request"
}

export function isSyncMessage(
  message: NetworkAdapterMessage
): message is SyncMessage {
  return message.type === "sync"
}

export function isEphemeralMessage(
  message: NetworkAdapterMessage | MessageContents
): message is EphemeralMessage | EphemeralMessageContents {
  return message.type === "ephemeral"
}

export interface SyncMessageEnvelope {
  senderId: PeerId
}

export interface SyncMessageContents {
  type: "sync"
  data: Uint8Array
  targetId: PeerId
  documentId: DocumentId
}

type static_assert<T extends true> = never

// export type SyncMessage = SyncMessageEnvelope & SyncMessageContents
// we inline the definitions here rather than using the above type alias because
// otherwise typedoc can't produce nice docs. We use this `static_assert` thing
// to make sure the types continue to line up though.
type _check_sync_message = static_assert<
  SyncMessage extends SyncMessageEnvelope & SyncMessageContents ? true : false
>
/**
 * A sync message for a particular document
 */
export type SyncMessage = {
  /** The peer ID of the sender of this message */
  senderId: PeerId
  type: "sync"
  /** The automerge sync message */
  data: Uint8Array
  /** The peer ID of the recipient of this message */
  targetId: PeerId
  /** The document ID of the document this message is for */
  documentId: DocumentId
}

export interface EphemeralMessageEnvelope {
  senderId: PeerId
  count: number
  sessionId: SessionId
}

export interface EphemeralMessageContents {
  type: "ephemeral"
  targetId: PeerId
  documentId: DocumentId
  data: Uint8Array
}

// export type EphemeralMessage = EphemeralMessageEnvelope & EphemeralMessageContents
// Inline definitions to get good docs, but check the types line up
type _check_ephemeral_message = static_assert<
  EphemeralMessage extends EphemeralMessageEnvelope & EphemeralMessageContents
    ? true
    : false
>

/** An ephemeral message
 *
 * @remarks
 * Ephemeral messages are not persisted anywhere and have no particular
 * structure. `automerge-repo` will gossip them around, in order to avoid
 * eternal loops of ephemeral messages every message has a session ID, which
 * is a random number generated by the sender at startup time, and a sequence
 * number. The combination of these two things allows us to discard messages
 * we have already seen.
 * */
export type EphemeralMessage = {
  /** The ID of the peer who sent this message */
  senderId: PeerId
  /** A sequence number which must be incremented for each message sent by this peer */
  count: number
  /** The ID of the session this message is part of. The sequence number for a given session always increases */
  sessionId: SessionId
  type: "ephemeral"
  /** The peer this message is for */
  targetId: PeerId
  /** The document ID this message pertains to */
  documentId: DocumentId
  /** The actual data of the message */
  data: Uint8Array
}

export interface DocumentUnavailableMessageContents {
  type: "doc-unavailable"
  documentId: DocumentId
  targetId: PeerId
}

// export type DocumentUnavailableMessage = SyncMessageEnvelope & DocumentUnavailableMessageContents
// Inline definitions to get good docs, but check the types line up
type _check_doc_unavailable = static_assert<
  DocumentUnavailableMessage extends SyncMessageEnvelope &
    DocumentUnavailableMessageContents
    ? true
    : false
>
/** Sent by a {@link Repo} to indicate that it does not have the document and none of it's connected peers do either */
export type DocumentUnavailableMessage = {
  /** The peer who sent this message */
  senderId: PeerId
  type: "doc-unavailable"
  /** The document which the peer claims it doesn't have */
  documentId: DocumentId
  /** The peer this message is for */
  targetId: PeerId
}

export interface RequestMessageContents {
  type: "request"
  data: Uint8Array
  targetId: PeerId
  documentId: DocumentId
}

// export type RequestMessage = SyncMessageEnvelope & RequestMessageContents
// Inline definitions to get good docs, but check the types line up
type _check_request_message = static_assert<
  RequestMessage extends SyncMessageEnvelope & RequestMessageContents
    ? true
    : false
>
// We inline the definitions here rather than using the above type alias because
// otherwise typedoc can't produce nice docs without exporting SyncMessageEnvelope
// and RequestMessageContents
/** Sent by a {@link Repo} to request a document from a peer
 *
 * @remarks
 * This is identical to a {@link SyncMessage} except that it is sent by a {@link Repo}
 * as the initial sync message when asking the other peer if it has the document.
 * */
export type RequestMessage = {
  /** The peer who sent this message */
  senderId: PeerId
  type: "request"
  /** The initial automerge sync message */
  data: Uint8Array
  /** The peer this message is for */
  targetId: PeerId
  /** The document ID this message requests */
  documentId: DocumentId
}

export type MessageContents =
  | SyncMessageContents
  | EphemeralMessageContents
  | RequestMessageContents
  | DocumentUnavailableMessageContents

/** The type of messages that {@link Repo} sends and receive to {@link NetworkAdapter}s */
export type Message =
  | SyncMessage
  | EphemeralMessage
  | RequestMessage
  | DocumentUnavailableMessage

export type SynchronizerMessage =
  | SyncMessage
  | RequestMessage
  | DocumentUnavailableMessage
  | EphemeralMessage

/** Notify the network that we have arrived so everyone knows our peer ID */
export type ArriveMessage = {
  /** Our peer ID */
  senderId: PeerId
  type: "arrive"
}

/** Respond to an arriving peer with our peer ID */
export type WelcomeMessage = {
  /** Our peer ID */
  senderId: PeerId
  /** The ID of the peer who sent the {@link ArriveMessage} we are responding to */
  targetId: PeerId
  type: "welcome"
}

/** The type of messages that {@link NetworkAdapter}s send and receive to each other
 *
 * @remarks
 * It is not _required_ that a {@link NetworkAdapter} use this message type.
 * NetworkAdapters are free to use whatever message type makes sense for their
 * transport. However, this type is a useful default.
 * */
export type NetworkAdapterMessage = ArriveMessage | WelcomeMessage | Message
